pragma language_version >= 0.16.0;
export { CoinInfo };

import CompactStandardLibrary;

export ledger unique_index: Counter;
export ledger nonce: Bytes<32>;
export ledger open_fixed_token_sales: Map<Bytes<32>, FixedSalesData>;
export ledger fixed_sales_bank: Map<Bytes<32>, QualifiedCoinInfo>;
export ledger fixed_sales_received_bank: Map<Bytes<32>, QualifiedCoinInfo>;

enum SaleStatus { live, ended, closed };

struct FixedSalesData{
    organizer: Bytes<32>;
    total_amount_for_sale: Uint<128>;
    total_amount_sold: Uint<128>;
    total_amount_left: Uint<128>;
    token_sale_ratio: Uint<32>;
    acceptable_exchange_token: Bytes<32>;
    status: SaleStatus;
    participant: Uint<16>;
    start_time: Bytes<32>;
    duration: Uint<64>;
    time_up: Boolean; //if time is up
    title: Opaque<"string">;
    desc: Opaque<"string">;
    project_logo: Opaque<"string">;
    project_banner: Opaque<"string">;
    token_name: Opaque<"string">;
    token_symbol: Opaque<"string">;
    min: Uint<64>;
    max: Uint<64>;
}

constructor(initialNonce: Bytes<32>) {
    nonce = disclose(initialNonce);
    unique_index.increment(1);
}

witness local_secret_key(): Bytes<32>;
witness generate_sale_id(): Bytes<32>;
witness calculate_amount_to_buy(received_amount: Uint<128>, sale_ratio: Uint<32>): Uint<128>;
witness calculate_time(start_time: Bytes<32>, duration: Uint<64>): Boolean;

export circuit create_token(
    token_name: Bytes<32>,
    total_amount: Uint<64>,
    token_ticker: Opaque<"string">,
    token_icon: Opaque<"string">,
    ) :[] {
    assert (total_amount >= 10, "token must be atleast 10");

    const new_nonce = evolveNonce(unique_index, nonce);
    // const domain_seperator = persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight-lp:token"), disclose(token_name)]);
    mintToken(disclose(token_name), disclose(total_amount), new_nonce, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
    unique_index.increment(1);
}

export circuit open_a_fixed_price_token_sale(
    coin: CoinInfo,
    sale_ratio: Uint<32>,
    acceptable_exchange_token: Bytes<32>,
    time: Bytes<32>,
    duration: Uint<32>,
    title: Opaque<"string">,
    desc: Opaque<"string">,
    logo: Opaque<"string">,
    banner: Opaque<"string">,
    token_name: Opaque<"string">,
    symbol: Opaque<"string">,
    min: Uint<64>,
    max: Uint<64>
    ) :[] {
    assert(sale_ratio > 0, "Sale ratio must be greater than 0!");
    assert(coin.value > 0, "Sale amount must be greater than 0!");
    receive(disclose(coin));
    const organizer = public_key(disclose(local_secret_key()));
    const sale_id = disclose(generate_sale_id());

    fixed_sales_bank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    open_fixed_token_sales.insert(sale_id, FixedSalesData {
        organizer,
        disclose(coin.value),
        0,
        disclose(coin.value),
        disclose(sale_ratio),
        disclose(acceptable_exchange_token),
        SaleStatus.live,
        0,
        disclose(time),
        disclose(duration),
        false,
        disclose(title),
        disclose(desc),
        disclose(logo),
        disclose(banner),
        disclose(token_name),
        disclose(symbol),
        disclose(min),
        disclose(max)
    });
}

export circuit buy_token_at_fixed_price(coin: CoinInfo, sale_id: Bytes<32>, sale_amount: Uint<128>) : [] {
    assert(sale_amount > 0, "Amount to buy must be greater than 0!");
    assert(open_fixed_token_sales.member(disclose(sale_id)), "There's currently no fixed sale for this token!");
    const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
    const amount_to_buy = disclose(calculate_amount_to_buy(sale_amount, sale_token_info.token_sale_ratio));
    assert(amount_to_buy <= sale_token_info.total_amount_left, "Amount is greater than amount left!");
    assert(coin.color == sale_token_info.acceptable_exchange_token, "This token color is not acceptable by organizer");
    const is_open = disclose(calculate_time(sale_token_info.start_time, sale_token_info.duration));
    open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        time_up: is_open ? true : false
    });
    
    assert (is_open, "This sale has ended!");
    
    // RECEIVES AND STORE TOKENS BUYERS PAY
    receive(disclose(coin));

    const newCoin = fixed_sales_received_bank.member(disclose(sale_id)) ? mergeCoinImmediate(fixed_sales_received_bank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
    fixed_sales_received_bank.insertCoin(disclose(sale_id), newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    const storeAccount = fixed_sales_bank.lookup(disclose(sale_id));
    const sendResult = send(storeAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), amount_to_buy);

    sendResult.change.is_some ? fixed_sales_bank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : fixed_sales_bank.remove(disclose(sale_id));
    
    // UPDATES FIXED SALES DATA LIST
    const new_total_sold = sale_token_info.total_amount_sold + amount_to_buy;
    const new_total_left = sale_token_info.total_amount_left - amount_to_buy;
    const participant_amount = sale_token_info.participant + 1;

    open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        total_amount_sold: new_total_sold as Uint<128>,
        total_amount_left: new_total_left,
        status: sale_token_info.total_amount_left == 0 ? SaleStatus.ended : SaleStatus.live,
        participant: participant_amount as Uint<16>
    });
}


export circuit closeSale(sale_id: Bytes<32>):[] {
    const organizer = public_key(disclose(local_secret_key()));
    const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
    assert(open_fixed_token_sales.member(disclose(sale_id)), "Sale with this id is not open");
    assert (sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
    assert (sale_token_info.status == SaleStatus.live, "Sale has ended already" );
    
    open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        status:SaleStatus.closed,
    });
}

export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight-lp:user"), sk]);
}