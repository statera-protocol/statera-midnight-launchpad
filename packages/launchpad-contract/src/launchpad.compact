pragma language_version >= 0.16.0;

export { CoinInfo };

import CompactStandardLibrary;

export ledger unique_index: Counter;
export ledger nonce: Bytes<32>;
export ledger saleBank: Map<Bytes<32>, QualifiedCoinInfo>;
export ledger receivedBank: Map<Bytes<32>, QualifiedCoinInfo>;
export ledger openFixedTokenSales: Map<Bytes<32>, FixedSalesData>;
export ledger openBatchTokenSales: Map<Bytes<32>, BatchSalesData>;
export ledger openOverflowTokenSales: Map<Bytes<32>, OverflowSalesData>;
export ledger contributors: MerkleTree<100, Bytes<32>>; // keep track of the list of contributors
// export ledger batch_buyers_info: Map<Bytes<32>, BatchBuyersData>; // keep track of contributors information

enum SaleStatus { live, completed, closed };

struct BuyerData {
    id: Bytes<32>;
    amount: Uint<64>;
};

struct FixedSalesData{
    organizer: Bytes<32>;
    totalAmountForSale: Uint<128>;
    totalAmountSold: Uint<128>;
    totalAmountLeft: Uint<128>;
    tokenSaleRatio: Uint<64>;
    acceptableExchangeToken: Bytes<32>;
    status: SaleStatus;
    participant: Uint<16>;
    startTime: Uint<64>;
    duration: Uint<8>;
    min: Uint<64>;
    max: Uint<64>;
    withdrawn: Boolean;
    timeUp: Boolean;
}

struct BatchSalesData{
    organizer: Bytes<32>;
    totalAmountForSale: Uint<128>;
    contribution: Uint<128>;
    acceptableExchangeToken: Bytes<32>;
    status: SaleStatus;
    participant: Uint<16>;
    startTime: Uint<64>;
    duration: Uint<8>;
    withdrawn: Boolean;
    timeUp: Boolean;
    min: Uint<64>;
    max: Uint<64>;
}

struct OverflowSalesData{
    organizer: Bytes<32>;
    totalAmountForSale: Uint<128>;
    contribution: Uint<128>;
    acceptableExchangeToken: Bytes<32>;
    target: Uint<128>;
    status: SaleStatus;
    participant: Uint<16>;
    startTime: Uint<64>;
    duration: Uint<8>;
    withdrawn: Boolean;
    timeUp: Boolean;
    min: Uint<64>;
    max: Uint<64>;
}

constructor(initialNonce: Bytes<32>) {
    nonce = disclose(initialNonce);
    unique_index.increment(1);
}

// WITNESSES
witness local_secret_key(): Bytes<32>;
witness generate_sale_id(): Bytes<32>;
witness calculate_amount_to_buy(received_amount: Uint<128>, sale_ratio: Uint<64>): Uint<128>;
witness calculate_time(startTime: Uint<64>, duration: Uint<8>): Boolean;
witness confirmContribution(buyerCommitment: Bytes<32>): MerkleTreePath<100, Bytes<32>>;
witness calcAmountToWtihdrawFromBatch(amountContributed: Uint<64>, totalReceived: Uint<64>, totalForSale: Uint<64> ): Uint<64>;
witness calcAmountToWtihdrawFromOverflow(amount: Uint<64>, totalReceived: Uint<64>, totalForSale: Uint<64>, targetAmount: Uint<64>): Uint<64>;
witness calcAmountToRefundFromOverflow(amount: Uint<64>, totalReceived: Uint<64>, totalForSale: Uint<64>, targetAmount: Uint<64>): Uint<64>;
witness calculateLeftover(totalReceived: Uint<64>, totalForSale: Uint<64>, targetAmount: Uint<64>): Uint<64>;

// GENERATE TOKEN
export circuit create_token(
    token_name: Bytes<32>,
    total_amount: Uint<64>,
    token_ticker: Opaque<"string">,
    token_icon: Opaque<"string">,
    ) :[] {
    assert (total_amount >= 10, "token must be atleast 10");

    const new_nonce = evolveNonce(unique_index, nonce);
    
    mintToken(
        disclose(token_name),
        disclose(total_amount),
        new_nonce,
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
    );
    unique_index.increment(1);
}

// CREATE FIXED SALE
export circuit openFixedSale(
    coin: CoinInfo,
    sale_ratio: Uint<64>,
    acceptableExchangeToken: Bytes<32>,
    creation_time: Uint<64>,
    sale_duration: Uint<8>,
    min: Uint<64>,
    max: Uint<64>,
    ) :[] {
    assert(sale_ratio > 0, "Sale ratio must be greater than 0!");
    assert(coin.value > 0, "Sale amount must be greater than 0!");
    receive(disclose(coin));
    const organizer = public_key(disclose(local_secret_key()));
    const sale_id = disclose(generate_sale_id());

    saleBank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    openFixedTokenSales.insert(sale_id, FixedSalesData {
        organizer,
        disclose(coin.value),
        0,
        disclose(coin.value),
        disclose(sale_ratio),
        disclose(acceptableExchangeToken),
        SaleStatus.live,
        0,
        disclose(creation_time),
        disclose(sale_duration),
        disclose(min),
        disclose(max),
        false,
        false
    });
}

// BUY FROM FIXED SALE
export circuit buyFromFixedSale(coin: CoinInfo, sale_id: Bytes<32>, sale_amount: Uint<128>) : [] {
    assert(sale_amount > 0, "Amount to buy must be greater than 0!");
    assert(openFixedTokenSales.member(disclose(sale_id)), "There's currently no fixed sale for this token!");
    const sale_token_info = openFixedTokenSales.lookup(disclose(sale_id));
    const amount_to_buy = disclose(calculate_amount_to_buy(sale_amount, sale_token_info.tokenSaleRatio));
    assert(amount_to_buy <= sale_token_info.totalAmountLeft, "Amount is greater than amount left!");
    assert(coin.color == sale_token_info.acceptableExchangeToken, "This token color is not acceptable by organizer");

    const is_closed = disclose(calculate_time(sale_token_info.startTime, sale_token_info.duration));

    openFixedTokenSales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        timeUp: is_closed ? true : false
    });
    
    assert(!is_closed, "This sale has been completed or closed");

    receive(disclose(coin));

    const newCoin = receivedBank.member(disclose(sale_id)) ? mergeCoinImmediate(receivedBank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
    receivedBank.insertCoin(disclose(sale_id), newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    const saleAccount = saleBank.lookup(disclose(sale_id));
    const sendResult = send(
        saleAccount,
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        amount_to_buy
    );

    sendResult.change.is_some ? saleBank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : saleBank.remove(disclose(sale_id));
    
    // UPDATES FIXED SALES DATA LIST
    const new_total_sold = sale_token_info.totalAmountSold + amount_to_buy;
    const new_total_left = sale_token_info.totalAmountLeft - amount_to_buy;
    const participant_amount = sale_token_info.participant + 1;

    openFixedTokenSales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        totalAmountSold: new_total_sold as Uint<128>,
        totalAmountLeft: new_total_left,
        status: sale_token_info.totalAmountSold == sale_token_info.totalAmountForSale ? SaleStatus.completed : SaleStatus.live,
        participant: participant_amount as Uint<16>
    });
}

// CREATE A BATCH SALE
export circuit openBatchSale(
    coin: CoinInfo,
    acceptableExchangeToken: Bytes<32>,
    creation_time: Uint<64>,
    sale_duration: Uint<8>,
    min: Uint<64>,
    max: Uint<64>
 ): [] {
    receive(disclose(coin));
    const organizer = disclose(public_key(disclose(local_secret_key())));
    const sale_id = disclose(generate_sale_id());

    saleBank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    openBatchTokenSales.insert(sale_id, BatchSalesData {
        organizer,
        disclose(coin.value),
        0,
        disclose(acceptableExchangeToken),
        SaleStatus.live,
        0,
        disclose(creation_time),
        disclose(sale_duration),
        false,
        false,
        disclose(min),
        disclose(max)
        }
    );
}

// BUY FROM BATCH SALE
export circuit buyFromBatchSale(coin: CoinInfo, sale_id: Bytes<32>, amount: Uint<64>) :[] {
    assert(amount > 0, "Amount to buy must be greater than 0!");
    assert(openBatchTokenSales.member(disclose(sale_id)), "There's currently no batch sale for this token!");
    const sale_token_info = openBatchTokenSales.lookup(disclose(sale_id));
    assert(coin.color == sale_token_info.acceptableExchangeToken, "This token color is not acceptable by organizer");

    const is_closed = disclose(calculate_time(sale_token_info.startTime, sale_token_info.duration));

    openBatchTokenSales.insert(disclose(sale_id), BatchSalesData {
        ...sale_token_info,
        timeUp: is_closed,
        status: is_closed ? SaleStatus.completed : SaleStatus.live
    });
    
    assert(!is_closed || sale_token_info.status == SaleStatus.closed, "This sale has been completed or closed");
    
    receive(disclose(coin));

    const newCoin = receivedBank.member(disclose(sale_id)) ? mergeCoinImmediate(receivedBank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
    receivedBank.insertCoin(
        disclose(sale_id),
        newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
    );

    const buyerInfo = BuyerData{
        id: disclose(local_secret_key()),
        amount: disclose(amount)
    };

    const userCommit = generateCommit(buyerInfo, disclose(sale_id));
    contributors.insert(userCommit);

    openBatchTokenSales.insert(disclose(sale_id), BatchSalesData {
        ...sale_token_info,
        contribution: sale_token_info.contribution + disclose(amount) as Uint<128>,
        participant: sale_token_info.participant + 1 as Uint<16>
        }
    );    
}

circuit generateCommit(value: BuyerData, rand: Bytes<32>): Bytes<32>{
    return persistentCommit<BuyerData>(value, rand);
}

// CREATE A OVERFLOW SALE
export circuit openOverflowSale(
    coin: CoinInfo,
    acceptableExchangeToken: Bytes<32>,
    creation_time: Uint<64>,
    sale_duration: Uint<8>,
    target: Uint<128>,
    min: Uint<64>,
    max: Uint<64>
 ): [] {
    receive(disclose(coin));
    const organizer = disclose(public_key(disclose(local_secret_key())));
    const sale_id = disclose(generate_sale_id());

    saleBank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    openOverflowTokenSales.insert(sale_id, OverflowSalesData {
        organizer,
        disclose(coin.value),
        0,
        disclose(acceptableExchangeToken),
        disclose(target),
        SaleStatus.live,
        0,
        disclose(creation_time),
        disclose(sale_duration),
        false,
        false,
        disclose(min),
        disclose(max)
        }
    );
}

// BUY FROM AN OVERFLOW SALE
export circuit buyFromOverflowSale(coin: CoinInfo, sale_id: Bytes<32>, amount: Uint<64>) :[] {
    assert(amount > 0, "Amount to buy must be greater than 0!");
    assert(openOverflowTokenSales.member(disclose(sale_id)), "This sale does not exist");
    const sale_token_info = openOverflowTokenSales.lookup(disclose(sale_id));
    assert(coin.color == sale_token_info.acceptableExchangeToken, "This token color is not acceptable by organizer");

    const is_closed = disclose(calculate_time(sale_token_info.startTime, sale_token_info.duration));

    openOverflowTokenSales.insert(disclose(sale_id), OverflowSalesData {
        ...sale_token_info,
        timeUp: is_closed,
        status: SaleStatus.completed
    });
    
    assert(!is_closed || sale_token_info.status == SaleStatus.closed, "This sale has been completed or closed");
    const person = disclose(public_key(disclose(local_secret_key())));

    receive(disclose(coin));

    const newCoin = receivedBank.member(disclose(sale_id)) ? mergeCoinImmediate(receivedBank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
    receivedBank.insertCoin(disclose(sale_id), newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    const buyerInfo = BuyerData {
        id: disclose(local_secret_key()),
        amount: disclose(amount)
    };

    const userCommit = generateCommit(buyerInfo, disclose(sale_id));
    contributors.insert(userCommit);
    
    openOverflowTokenSales.insert(disclose(sale_id), OverflowSalesData {
        ...sale_token_info,
        contribution: sale_token_info.contribution + disclose(coin.value) as Uint<128>,
        participant: sale_token_info.participant + 1 as Uint<16>
        }
    );    
}

// USER WITHDRAWAL FROM BATCH FIXED SALE
export circuit withdrawalFromBatchSale(sale_id: Bytes<32>, amountContributed: Uint<64>):[] {
    assert(openBatchTokenSales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = openBatchTokenSales.lookup(disclose(sale_id));
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    // const buyers_info = ;
    
    const buyerInfo = BuyerData {
        id: disclose(local_secret_key()),
        amount: disclose(amountContributed)
    };

    const userCommitRegenerate = generateCommit(buyerInfo, disclose(sale_id));
    const path = disclose(confirmContribution(userCommitRegenerate)); 
    assert(contributors.checkRoot(merkleTreePathRoot<100, Bytes<32>>(path)), "You did not contribute to this sale");

    const totalReceived = receivedBank.lookup(disclose(sale_id)).value;
    const withdrawalAmount = disclose(
        calcAmountToWtihdrawFromBatch(
            disclose(amountContributed),
            totalReceived as Uint<64>,
            sale_token_info.totalAmountForSale as Uint<64>
        )
    );

    const sendResult = send(
        saleBank.lookup(disclose(sale_id)),
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        withdrawalAmount
    );

    sendResult.change.is_some ? saleBank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : saleBank.remove(disclose(sale_id));
}

// USER WITHDRAWAL FROM OVERFLOW SALE
export circuit withdrawFromOverflowSale(sale_id: Bytes<32>, amountContributed: Uint<64>) :[] {
    assert(openOverflowTokenSales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = openOverflowTokenSales.lookup(disclose(sale_id));
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    
    const buyerInfo = BuyerData {
        id: disclose(local_secret_key()),
        amount: disclose(amountContributed)
    };

    const userCommitRegenerate = generateCommit(buyerInfo, disclose(sale_id));
    const path = disclose(confirmContribution(userCommitRegenerate)); 
    assert(contributors.checkRoot(merkleTreePathRoot<100, Bytes<32>>(path)), "You did not contribute to this sale");

    const totalReceived = receivedBank.lookup(disclose(sale_id)).value;
    
    const withdrawalAmount = disclose(
        calcAmountToWtihdrawFromOverflow(disclose(amountContributed),
            totalReceived as Uint<64>,
            sale_token_info.totalAmountForSale as Uint<64>,
            sale_token_info.target as Uint<64>
        )
    );
    
    const refundAmount = disclose(
        calcAmountToRefundFromOverflow(disclose(amountContributed),
        totalReceived as Uint<64>,
        sale_token_info.totalAmountForSale as Uint<64>,
        sale_token_info.target as Uint<64>)
    );
    
    const sendResult = send(
        saleBank.lookup(disclose(sale_id)),
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        withdrawalAmount
    ); //sends token bought to contributors
    
    sendResult.change.is_some ? saleBank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : saleBank.remove(disclose(sale_id));

    const refundSendResult = send(
        receivedBank.lookup(disclose(sale_id)),
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        refundAmount
    ); // sends refund to contributor

    refundSendResult.change.is_some ? saleBank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : saleBank.remove(disclose(sale_id));
}


// SALE CLOSURE
export circuit closeFixedSale(sale_id: Bytes<32>):[] {
    const organizer = public_key(disclose(local_secret_key()));
    assert(openFixedTokenSales.member(disclose(sale_id)), "Sale with this id does not exist");
        const sale_token_info = openFixedTokenSales.lookup(disclose(sale_id));
        assert (sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
        assert (sale_token_info.status == SaleStatus.live, "Sale has ended already" );
    
    openFixedTokenSales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        status:SaleStatus.closed,
    });
}

export circuit closeBatchSale(sale_id: Bytes<32>):[] {
    const organizer = public_key(disclose(local_secret_key()));
    assert(openBatchTokenSales.member(disclose(sale_id)), "Sale with this id does not exist");
        const sale_token_info = openBatchTokenSales.lookup(disclose(sale_id));
        assert (sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
        assert (sale_token_info.status == SaleStatus.live, "Sale has ended already" );
    
    openBatchTokenSales.insert(disclose(sale_id), BatchSalesData {
        ...sale_token_info,
        status: SaleStatus.closed,
    });
}

export circuit closeOverflowSale(sale_id: Bytes<32>):[] {
    const organizer = public_key(disclose(local_secret_key()));
    assert(openOverflowTokenSales.member(disclose(sale_id)), "Sale with this id does not exist");
    const sale_token_info = openOverflowTokenSales.lookup(disclose(sale_id));
    assert (sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
    assert (sale_token_info.status == SaleStatus.live, "Sale has ended already" );
    
    openOverflowTokenSales.insert(disclose(sale_id), OverflowSalesData {
        ...sale_token_info,
        status: SaleStatus.closed,
    });
}

// ORGANIZER WITHDRAWAL
export circuit organizerWIthdrawalFromFixedSale(sale_id: Bytes<32>): [] {
    const organizer = public_key(disclose(local_secret_key()));
    assert(openFixedTokenSales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = openFixedTokenSales.lookup(disclose(sale_id));
    assert(sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    assert(sale_token_info.withdrawn == false, "Funds from this sale has already been withdrawn!");
    assert(receivedBank.member(disclose(sale_id)), "This sale has not received any funds");

    const receivedAccount = receivedBank.lookup(disclose(sale_id));

    send(receivedAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), receivedAccount.value);

    receivedBank.remove(disclose(sale_id));

    openFixedTokenSales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        withdrawn: true
    });
}

export circuit organizerWIthdrawalFromBatchSale(sale_id: Bytes<32>):[] {
    const organizer = public_key(disclose(local_secret_key()));
    assert(openBatchTokenSales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = openBatchTokenSales.lookup(disclose(sale_id));
    assert(sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    assert(sale_token_info.withdrawn == false, "Funds from this sale has already been withdrawn!");
    assert(receivedBank.member(disclose(sale_id)), "This sale has not received any funds");

    const receivedAccount = receivedBank.lookup(disclose(sale_id));

    send(receivedAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), receivedAccount.value);

    receivedBank.remove(disclose(sale_id));

    openBatchTokenSales.insert(disclose(sale_id), BatchSalesData {
        ...sale_token_info,
        withdrawn: true
    });
}

export circuit organizerWIthdrawalFromOverflowSale(sale_id: Bytes<32>):[] {
    const organizer = public_key(disclose(local_secret_key()));
    assert(openOverflowTokenSales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = openOverflowTokenSales.lookup(disclose(sale_id));
    assert(sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    assert(sale_token_info.withdrawn == false, "Funds from this sale has already been withdrawn!");
    assert(receivedBank.member(disclose(sale_id)), "This sale has not received any funds");

    const receivedAccount = receivedBank.lookup(disclose(sale_id));
    const saleAccount = saleBank.lookup(disclose(sale_id));

    // calculate the amount to withdraw based on target acquired
    const leftover = disclose(calculateLeftover(
        sale_token_info.contribution as Uint<64>,
        sale_token_info.totalAmountForSale as Uint<64>,
        sale_token_info.target as Uint<64>
    ));
    const sendResult = send(
        saleAccount,
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        leftover
    );
    sendResult.change.is_some ? saleBank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : saleBank.remove(disclose(sale_id));

    const amountToWithdraw = sale_token_info.target > sale_token_info.contribution ? sale_token_info.contribution : sale_token_info.target;
    const withdrawalSendResult = send(
        receivedAccount,
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        amountToWithdraw
    );
    withdrawalSendResult.change.is_some ? receivedBank.insertCoin(disclose(sale_id), withdrawalSendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : saleBank.remove(disclose(sale_id));

    receivedBank.remove(disclose(sale_id));

    openOverflowTokenSales.insert(disclose(sale_id), OverflowSalesData {
        ...sale_token_info,
        withdrawn: true
    });
    
}

export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight-lp:user"), sk]);
}