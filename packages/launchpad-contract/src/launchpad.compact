pragma language_version >= 0.16.0;

import CompactStandardLibrary;

export ledger uniqueIndex: Counter;
export ledger nonce: Bytes<32>;
export ledger tokensList: Map<Bytes<32>, TokenDetails>;

struct TokenDetails {
    name: Bytes<32>;
    minter: Bytes<32>;
    amount: Uint<64>;
    ticker: Opaque<"string">;
}

constructor(initialNonce: Bytes<32>) {
    nonce = disclose(initialNonce);
    uniqueIndex.increment(1);
}

witness local_secret_key(): Bytes<32>;

export circuit mintYourToken(_name: Bytes<32>, _amount: Uint<64>, _ticker: Opaque<"string"> ) : [] {
    assert (_amount >= 100, "token must be atleast 100");
    const disclosedName = disclose(_name);
    assert(!tokensList.member(disclosedName), "Token with this name already exist!.");
    const new_nonce = evolveNonce(uniqueIndex, nonce);
    const minter = disclose(public_key(local_secret_key()));
    const coin = mintToken(pad(32, "midnight_lp_token"), disclose(_amount), new_nonce, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
    tokensList.insert(disclosedName, TokenDetails{disclosedName, minter, disclose(_amount), disclose(_ticker)});
    uniqueIndex.increment(1);
}

export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight-lp:user"), sk]);
}