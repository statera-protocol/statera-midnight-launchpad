pragma language_version >= 0.16.0;

export { CoinInfo };

import CompactStandardLibrary;

export ledger unique_index: Counter;
export ledger nonce: Bytes<32>;
export ledger sales_bank: Map<Bytes<32>, QualifiedCoinInfo>;
export ledger received_bank: Map<Bytes<32>, QualifiedCoinInfo>;
export ledger open_fixed_token_sales: Map<Bytes<32>, FixedSalesData>;
export ledger open_batch_token_sales: Map<Bytes<32>, BatchSalesData>;
export ledger open_overflow_token_sales: Map<Bytes<32>, OverflowSalesData>;
export ledger batch_contributors: Map<Bytes<32>, Set<Bytes<32>>>; // keep track of the list of contributors
export ledger overflow_contributors: Map<Bytes<32>, Set<Bytes<32>>>;
// export ledger batch_buyers_info: Map<Bytes<32>, BatchBuyersData>; // keep track of contributors information

enum SaleStatus { live, completed, closed };

struct BuyerType {is_contributor: Boolean, has_withdraw: Boolean, value: Uint<64>};

struct FixedSalesData{
    organizer: Bytes<32>;
    total_amount_for_sale: Uint<128>;
    total_amount_sold: Uint<128>;
    total_amount_left: Uint<128>;
    token_sale_ratio: Uint<64>;
    hard_cap: Uint<128>;
    acceptable_exchange_token: Bytes<32>;
    status: SaleStatus;
    participant: Uint<16>;
    start_time: Uint<64>;
    duration: Uint<8>;
    min: Uint<64>;
    max: Uint<64>;
    withdrawn: Boolean;
    time_up: Boolean;
}

struct BatchSalesData{
    organizer: Bytes<32>;
    total_amount_for_sale: Uint<128>;
    contribution: Uint<128>;
    acceptable_exchange_token: Bytes<32>;
    status: SaleStatus;
    participant: Uint<16>;
    start_time: Uint<64>;
    duration: Uint<8>;
    withdrawn: Boolean;
    time_up: Boolean;
    min: Uint<64>;
    max: Uint<64>;
}

struct OverflowSalesData{
    organizer: Bytes<32>;
    total_amount_for_sale: Uint<128>;
    contribution: Uint<128>;
    acceptable_exchange_token: Bytes<32>;
    target: Uint<128>;
    status: SaleStatus;
    participant: Uint<16>;
    start_time: Uint<64>;
    duration: Uint<8>;
    withdrawn: Boolean;
    time_up: Boolean;
    min: Uint<64>;
    max: Uint<64>;
}

constructor(initialNonce: Bytes<32>) {
    nonce = disclose(initialNonce);
    unique_index.increment(1);
}

// WITNESSES
witness local_secret_key(): Bytes<32>;
witness generate_sale_id(): Bytes<32>;
witness calculate_amount_to_buy(received_amount: Uint<128>, sale_ratio: Uint<64>): Uint<128>;
witness calculate_time(start_time: Uint<64>, duration: Uint<8>): Boolean;
witness encodeBuyerHash(pk: Bytes<32>, withdrawal_state:Boolean, amount: Uint<64> ): Bytes<32>;
witness decodeBuyerHash(encrypt: Bytes<32>, totalReceived: Uint<64>, totalForSale: Uint<64> ): Uint<64>;
witness decodeBuyerHashOverflow(encrypt: Bytes<32>, totalReceived: Uint<64>, totalForSale: Uint<64>, targetAmount: Uint<64>, returnType: Bytes<6> ): Uint<64>;

// GENERATE TOKEN
export circuit create_token(
    token_name: Bytes<32>,
    total_amount: Uint<64>,
    token_ticker: Opaque<"string">,
    token_icon: Opaque<"string">,
    ) :[] {
    assert (total_amount >= 10, "token must be atleast 10");

    const new_nonce = evolveNonce(unique_index, nonce);
    
    mintToken(disclose(token_name), disclose(total_amount), new_nonce, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
    unique_index.increment(1);
}

// CREATE FIXED SALE
export circuit open_fixed_sale(
    coin: CoinInfo,
    sale_ratio: Uint<64>,
    acceptable_exchange_token: Bytes<32>,
    creation_time: Uint<64>,
    sale_duration: Uint<8>,
    min: Uint<64>,
    max: Uint<64>,
    token_hard_cap: Uint<64>
    ) :[] {
    assert(sale_ratio > 0, "Sale ratio must be greater than 0!");
    assert(coin.value > 0, "Sale amount must be greater than 0!");
    receive(disclose(coin));
    const organizer = public_key(disclose(local_secret_key()));
    const sale_id = disclose(generate_sale_id());

    sales_bank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    open_fixed_token_sales.insert(sale_id, FixedSalesData {
        organizer,
        disclose(coin.value),
        0,
        disclose(coin.value),
        disclose(sale_ratio),
        disclose(token_hard_cap),
        disclose(acceptable_exchange_token),
        SaleStatus.live,
        0,
        disclose(creation_time),
        disclose(sale_duration),
        disclose(min),
        disclose(max),
        false,
        false
    });
}

// BUY FROM FIXED SALE
export circuit buy_from_fixed_price(coin: CoinInfo, sale_id: Bytes<32>, sale_amount: Uint<128>) : [] {
    assert(sale_amount > 0, "Amount to buy must be greater than 0!");
    assert(open_fixed_token_sales.member(disclose(sale_id)), "There's currently no fixed sale for this token!");
    const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
    const amount_to_buy = disclose(calculate_amount_to_buy(sale_amount, sale_token_info.token_sale_ratio));
    assert(amount_to_buy <= sale_token_info.total_amount_left, "Amount is greater than amount left!");
    assert(coin.color == sale_token_info.acceptable_exchange_token, "This token color is not acceptable by organizer");

    const is_closed = disclose(calculate_time(sale_token_info.start_time, sale_token_info.duration));

    open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        time_up: is_closed ? true : false
    });
    
    assert(!is_closed, "This sale has been completed or closed");

    receive(disclose(coin));

    const newCoin = received_bank.member(disclose(sale_id)) ? mergeCoinImmediate(received_bank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
    received_bank.insertCoin(disclose(sale_id), newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    const saleAccount = sales_bank.lookup(disclose(sale_id));
    const sendResult = send(saleAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), amount_to_buy);

    sendResult.change.is_some ? sales_bank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : sales_bank.remove(disclose(sale_id));
    
    // UPDATES FIXED SALES DATA LIST
    const new_total_sold = sale_token_info.total_amount_sold + amount_to_buy;
    const new_total_left = sale_token_info.total_amount_left - amount_to_buy;
    const participant_amount = sale_token_info.participant + 1;

    open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        total_amount_sold: new_total_sold as Uint<128>,
        total_amount_left: new_total_left,
        status: sale_token_info.total_amount_sold == sale_token_info.total_amount_for_sale ? SaleStatus.completed : SaleStatus.live,
        participant: participant_amount as Uint<16>
    });
}

// CREATE A BATCH SALE
export circuit open_batch_sale(
    coin: CoinInfo,
    acceptable_exchange_token: Bytes<32>,
    creation_time: Uint<64>,
    sale_duration: Uint<8>,
    min: Uint<64>,
    max: Uint<64>
 ): [] {
    receive(disclose(coin));
    const organizer = disclose(public_key(disclose(local_secret_key())));
    const sale_id = disclose(generate_sale_id());

    sales_bank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    open_batch_token_sales.insert(sale_id, BatchSalesData {
        organizer,
        disclose(coin.value),
        0,
        disclose(acceptable_exchange_token),
        SaleStatus.live,
        0,
        disclose(creation_time),
        disclose(sale_duration),
        false,
        false,
        disclose(min),
        disclose(max)
        }
    );
}

// BUY FROM BATCH SALE
export circuit buy_from_batch_sale(coin: CoinInfo, sale_id: Bytes<32>, amount: Uint<64>) :[] {
    assert(coin.value > 0, "Amount to buy must be greater than 0!");
    assert(open_batch_token_sales.member(disclose(sale_id)), "There's currently no batch sale for this token!");
    const sale_token_info = open_batch_token_sales.lookup(disclose(sale_id));
    assert(coin.color == sale_token_info.acceptable_exchange_token, "This token color is not acceptable by organizer");

    const is_closed = disclose(calculate_time(sale_token_info.start_time, sale_token_info.duration));

    open_batch_token_sales.insert(disclose(sale_id), BatchSalesData {
        ...sale_token_info,
        time_up: is_closed,
        status: SaleStatus.completed
    });
    
    assert(!is_closed || sale_token_info.status == SaleStatus.closed, "This sale has been completed or closed");
    const contributor = disclose(public_key(disclose(local_secret_key())));

    receive(disclose(coin));

    const newCoin = received_bank.member(disclose(sale_id)) ? mergeCoinImmediate(received_bank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
    received_bank.insertCoin(disclose(sale_id), newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    // fetch the list by id
    const buyer_encode = disclose(encodeBuyerHash(contributor, false, amount));

    batch_contributors.lookup(disclose(sale_id)).insert(buyer_encode);

    

    open_batch_token_sales.insert(disclose(sale_id), BatchSalesData {
        ...sale_token_info,
        contribution: sale_token_info.contribution + disclose(amount) as Uint<128>,
        participant: sale_token_info.participant + 1 as Uint<16>
        }
    );    
}

// CREATE A OVERFLOW SALE
export circuit open_overflow_sale(
    coin: CoinInfo,
    acceptable_exchange_token: Bytes<32>,
    creation_time: Uint<64>,
    sale_duration: Uint<8>,
    target: Uint<128>,
    min: Uint<64>,
    max: Uint<64>
 ): [] {
    receive(disclose(coin));
    const organizer = disclose(public_key(disclose(local_secret_key())));
    const sale_id = disclose(generate_sale_id());

    sales_bank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    open_overflow_token_sales.insert(sale_id, OverflowSalesData {
        organizer,
        disclose(coin.value),
        0,
        disclose(acceptable_exchange_token),
        disclose(target),
        SaleStatus.live,
        0,
        disclose(creation_time),
        disclose(sale_duration),
        false,
        false,
        disclose(min),
        disclose(max)
        }
    );
}

// BUY FROM AN OVERFLOW SALE
export circuit buy_from_overflow_sale(coin: CoinInfo, sale_id: Bytes<32>) :[] {
    assert(coin.value > 0, "Amount to buy must be greater than 0!");
    assert(open_overflow_token_sales.member(disclose(sale_id)), "This sale does not exist");
    const sale_token_info = open_overflow_token_sales.lookup(disclose(sale_id));
    assert(coin.color == sale_token_info.acceptable_exchange_token, "This token color is not acceptable by organizer");

    const is_closed = disclose(calculate_time(sale_token_info.start_time, sale_token_info.duration));

    open_overflow_token_sales.insert(disclose(sale_id), OverflowSalesData {
        ...sale_token_info,
        time_up: is_closed,
        status: SaleStatus.completed
    });
    
    assert(!is_closed || sale_token_info.status == SaleStatus.closed, "This sale has been completed or closed");
    const contributor = disclose(public_key(disclose(local_secret_key())));

    receive(disclose(coin));

    const newCoin = received_bank.member(disclose(sale_id)) ? mergeCoinImmediate(received_bank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
    received_bank.insertCoin(disclose(sale_id), newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    // fetch the list by id
    const buyer_encode = disclose(encodeBuyerHash(contributor, false, disclose(coin.value) as Uint<64> ));

    overflow_contributors.lookup(disclose(sale_id)).insert(buyer_encode);

    open_overflow_token_sales.insert(disclose(sale_id), OverflowSalesData {
        ...sale_token_info,
        contribution: sale_token_info.contribution + disclose(coin.value) as Uint<128>,
        participant: sale_token_info.participant + 1 as Uint<16>
        }
    );    
}

// USERS WITHDRAWAL
export circuit withdrawal_from_batch(sale_id: Bytes<32>, amount: Uint<64>):[] {
    assert(open_batch_token_sales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = open_batch_token_sales.lookup(disclose(sale_id));
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    const person = disclose(public_key(disclose(local_secret_key())));
    // const buyers_info = ;
    const encode = disclose(encodeBuyerHash(person, false, disclose(amount)));
    assert (batch_contributors.member(encode), "You did not contribute to this sale");
    
    const totalReceived = received_bank.lookup(disclose(sale_id)).value;
    const withdrawal_amount = disclose(decodeBuyerHash(encode, totalReceived as Uint<64>, sale_token_info.total_amount_for_sale as Uint<64>)); // checks if person has withdraw before and also calculate the amount a user can withdraw
    // we send the total amount of received token, the sale token amount, the participants amount and the 
    assert (withdrawal_amount > 0, "You've already withdrawn from this sale.");

    const storeAccount = sales_bank.lookup(disclose(sale_id));

    const sendResult = send(storeAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), withdrawal_amount);

    sendResult.change.is_some ? sales_bank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : sales_bank.remove(disclose(sale_id));

    batch_contributors.lookup(disclose(sale_id)).remove(encode); //remove the previous encode from buyer's list 

    const new_encode = disclose(encodeBuyerHash(person, true, amount));

    batch_contributors.lookup(disclose(sale_id)).insert(new_encode); //inserts a new encode for buyer to prevent double withdrawal
}

// WITHDRAW FROM OVERFLOW SALES
export circuit withdraw_from_overflow(sale_id: Bytes<32>, amount: Uint<64>) :[] {
    assert(open_overflow_token_sales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = open_overflow_token_sales.lookup(disclose(sale_id));
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    const person = disclose(public_key(disclose(local_secret_key())));
    // const buyers_info = ;
    const encode = disclose(encodeBuyerHash(person, false, disclose(amount)));
    assert (batch_contributors.member(encode), "You did not contribute to this sale");
    
    const totalReceived = received_bank.lookup(disclose(sale_id)).value;
    
    const withdrawal_amount = disclose(decodeBuyerHashOverflow(encode, totalReceived as Uint<64>, sale_token_info.total_amount_for_sale as Uint<64>, sale_token_info.target as Uint<64>, "tokens"));
    
    const refund_amount = disclose(decodeBuyerHashOverflow(encode, totalReceived as Uint<64>, sale_token_info.total_amount_for_sale as Uint<64>, sale_token_info.target as Uint<64>, "refund"));
    // checks if person has withdraw before and also calculate the amount a user can withdraw
    // we send the total amount of received token, the sale token amount, the participants amount and the 
    assert (withdrawal_amount > 0, "You've already withdrawn from this sale.");

    const saleAccount = sales_bank.lookup(disclose(sale_id));
    const receiveAccount = received_bank.lookup(disclose(sale_id));
    
    const sendResult = send(saleAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), withdrawal_amount); //sends token bought to contributors
    sendResult.change.is_some ? sales_bank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : sales_bank.remove(disclose(sale_id));

    const refundSendResult = send(receiveAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), refund_amount); // sends refund to contributor

    refundSendResult.change.is_some ? sales_bank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : sales_bank.remove(disclose(sale_id));

    batch_contributors.lookup(disclose(sale_id)).remove(encode); //remove the previous encode from buyer's list 

    const new_encode = disclose(encodeBuyerHash(person, true, amount));

    batch_contributors.lookup(disclose(sale_id)).insert(new_encode); //inserts a new encode for buyer to prevent double withdrawal
}

// SALE CLOSURE
export circuit closeSale(sale_id: Bytes<32>, sale_type: Uint<8>):[] {
    const organizer = public_key(disclose(local_secret_key()));
    
    if (disclose(sale_type) == 1) {
        assert(open_fixed_token_sales.member(disclose(sale_id)), "Sale with this id does not exist");
        const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
        assert (sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
        assert (sale_token_info.status == SaleStatus.live, "Sale has ended already" );
    
        open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
            ...sale_token_info,
            status:SaleStatus.closed,
        });
    } else if (disclose(sale_type) == 2) {
        assert(open_batch_token_sales.member(disclose(sale_id)), "Sale with this id does not exist");
        const sale_token_info = open_batch_token_sales.lookup(disclose(sale_id));
        assert (sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
        assert (sale_token_info.status == SaleStatus.live, "Sale has ended already" );
        
        open_batch_token_sales.insert(disclose(sale_id), BatchSalesData {
            ...sale_token_info,
            status: SaleStatus.closed,
        }); 
    }
}

// ORGANIZER WITHDRAWAL
export circuit organizers_withdrawal(sale_id: Bytes<32>): [] {
    const organizer = public_key(disclose(local_secret_key()));
    assert(open_fixed_token_sales.member(disclose(sale_id)), "This sale doesn't exist existed!");
    const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
    assert(sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
    assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale is still on, can't withdraw from it" );
    assert(sale_token_info.withdrawn == false, "Funds from this sale has already been withdrawn!");
    assert(received_bank.member(disclose(sale_id)), "This sale has not received any funds");

    const account = received_bank.lookup(disclose(sale_id));

    send(account, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), account.value);

    received_bank.remove(disclose(sale_id));

    open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
        ...sale_token_info,
        withdrawn: true
    });
}

export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight-lp:user"), sk]);
}




// pragma language_version >= 0.16.0;
// export { CoinInfo };

// import CompactStandardLibrary;

// export ledger unique_index: Counter;
// export ledger nonce: Bytes<32>;
// export ledger open_fixed_token_sales: Map<Bytes<32>, FixedSalesData>;
// export ledger fixed_sales_bank: Map<Bytes<32>, QualifiedCoinInfo>;
// export ledger fixed_sales_received_bank: Map<Bytes<32>, QualifiedCoinInfo>;


// export ledger trial_map: Map<Bytes<32>, List<BuyerInfo>>;

// struct BuyerInfo {
//     pk: Bytes<32>;
//     amount: Uint<64>;
// }

// enum SaleStatus { live, completed, closed };

// struct FixedSalesData{
//     organizer: Bytes<32>;
//     total_amount_for_sale: Uint<128>;
//     total_amount_sold: Uint<128>;
//     total_amount_left: Uint<128>;
//     token_sale_ratio: Uint<64>;
//     hard_cap: Uint<128>;
//     acceptable_exchange_token: Bytes<32>;
//     status: SaleStatus;
//     participant: Uint<16>;
//     start_time: Uint<64>;
//     duration: Uint<8>;
//     token_symbol: Opaque<"string">;
//     acceptable_token_symbol: Opaque<"string">;
//     min: Uint<64>;
//     max: Uint<64>;
//     withdrawn: Boolean;
//     time_up: Boolean;
// }

// constructor(initialNonce: Bytes<32>) {
//     nonce = disclose(initialNonce);
//     unique_index.increment(1);
// }

// witness local_secret_key(): Bytes<32>;
// witness generate_sale_id(): Bytes<32>;
// witness calculate_amount_to_buy(received_amount: Uint<128>, sale_ratio: Uint<64>): Uint<128>;
// witness calculate_time(start_time: Uint<64>, duration: Uint<8>): Boolean;

// export circuit create_token(
//     token_name: Bytes<32>,
//     total_amount: Uint<64>,
//     token_ticker: Opaque<"string">,
//     token_icon: Opaque<"string">,
//     ) :[] {
//     assert (total_amount >= 10, "token must be atleast 10");

//     const new_nonce = evolveNonce(unique_index, nonce);
    
//     mintToken(disclose(token_name), disclose(total_amount), new_nonce, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
//     unique_index.increment(1);
// }

// export circuit open_a_fixed_price_token_sale(
//     coin: CoinInfo,
//     sale_ratio: Uint<64>,
//     acceptable_exchange_token: Bytes<32>,
//     creation_time: Uint<64>,
//     sale_duration: Uint<8>,
//     token_symbol: Opaque<"string">,
//     acceptable_token_symbol: Opaque<"string">,
//     min: Uint<64>,
//     max: Uint<64>,
//     token_hard_cap: Uint<64>
//     ) :[] {
//     assert(sale_ratio > 0, "Sale ratio must be greater than 0!");
//     assert(coin.value > 0, "Sale amount must be greater than 0!");
//     receive(disclose(coin));
//     const organizer = public_key(disclose(local_secret_key()));
//     const sale_id = disclose(generate_sale_id());

//     fixed_sales_bank.insertCoin(disclose(sale_id), disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

//     open_fixed_token_sales.insert(sale_id, FixedSalesData {
//         organizer,
//         disclose(coin.value),
//         0,
//         disclose(coin.value),
//         disclose(sale_ratio),
//         disclose(token_hard_cap),
//         disclose(acceptable_exchange_token),
//         SaleStatus.live,
//         0,
//         disclose(creation_time),
//         disclose(sale_duration),
//         disclose(token_symbol),
//         disclose(acceptable_token_symbol),
//         disclose(min),
//         disclose(max),
//         false,
//         false
//     });
// }

// export circuit buy_token_at_fixed_price(coin: CoinInfo, sale_id: Bytes<32>, sale_amount: Uint<128>) : [] {
//     assert(sale_amount > 0, "Amount to buy must be greater than 0!");
//     assert(open_fixed_token_sales.member(disclose(sale_id)), "There's currently no fixed sale for this token!");
//     const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
//     const amount_to_buy = disclose(calculate_amount_to_buy(sale_amount, sale_token_info.token_sale_ratio));
//     assert(amount_to_buy <= sale_token_info.total_amount_left, "Amount is greater than amount left!");
//     assert(coin.color == sale_token_info.acceptable_exchange_token, "This token color is not acceptable by organizer");

//     const is_closed = disclose(calculate_time(sale_token_info.start_time, sale_token_info.duration));

//     open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
//         ...sale_token_info,
//         time_up: is_closed
//     });
    
//     assert(!is_closed, "This sale has been completed or closed");

//     receive(disclose(coin));

//     const newCoin = fixed_sales_received_bank.member(disclose(sale_id)) ? mergeCoinImmediate(fixed_sales_received_bank.lookup(disclose(sale_id)), disclose(coin)) : disclose(coin);
//     fixed_sales_received_bank.insertCoin(disclose(sale_id), newCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

//     const saleAccount = fixed_sales_bank.lookup(disclose(sale_id));
//     const sendResult = send(saleAccount, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), amount_to_buy);

//     sendResult.change.is_some ? fixed_sales_bank.insertCoin(disclose(sale_id), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) : fixed_sales_bank.remove(disclose(sale_id));
    
//     // UPDATES FIXED SALES DATA LIST
//     const new_total_sold = sale_token_info.total_amount_sold + amount_to_buy;
//     const new_total_left = sale_token_info.total_amount_left - amount_to_buy;
//     const participant_amount = sale_token_info.participant + 1;

//     open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
//         ...sale_token_info,
//         total_amount_sold: new_total_sold as Uint<128>,
//         total_amount_left: new_total_left,
//         status: sale_token_info.total_amount_sold == sale_token_info.total_amount_for_sale ? SaleStatus.completed : SaleStatus.live,
//         participant: participant_amount as Uint<16>
//     });
// }


// export circuit closeSale(sale_id: Bytes<32>):[] {
//     const organizer = public_key(disclose(local_secret_key()));
//     const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
//     assert(open_fixed_token_sales.member(disclose(sale_id)), "Sale with this id is not open");
//     assert (sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
//     assert (sale_token_info.status == SaleStatus.live, "Sale has ended already" );
    
//     open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
//         ...sale_token_info,
//         status:SaleStatus.closed,
//     });
// }

// export circuit withdraw_token(sale_id: Bytes<32>): [] {
//     const organizer = public_key(disclose(local_secret_key()));
//     const sale_token_info = open_fixed_token_sales.lookup(disclose(sale_id));
//     assert(open_fixed_token_sales.member(disclose(sale_id)), "Sale with this id never existed!");
//     assert(sale_token_info.organizer == organizer, "Unauthorized!. You are not the organizer");
//     assert(sale_token_info.status == SaleStatus.closed || sale_token_info.status == SaleStatus.completed, "Sale has ended already" );
//     assert(sale_token_info.withdrawn == false, "Funds from this sale has already been withdrawn!");
//     assert(fixed_sales_received_bank.member(disclose(sale_id)), "This sale has not received any funds");

//     const account = fixed_sales_received_bank.lookup(disclose(sale_id));

//     send(account, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), account.value);

//     fixed_sales_received_bank.remove(disclose(sale_id));

//     open_fixed_token_sales.insert(disclose(sale_id), FixedSalesData {
//         ...sale_token_info,
//         withdrawn: true
//     });
// }

// export circuit public_key(sk: Bytes<32>): Bytes<32> {
//     return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnight-lp:user"), sk]);
// }